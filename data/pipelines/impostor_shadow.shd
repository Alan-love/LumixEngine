include "pipelines/common.glsl"

compute_shader [[
	layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
	layout (rgba8, binding = 0) uniform writeonly image2D u_output;
	layout (binding = 1) uniform sampler2D u_depth;
	layout(std140, binding = 4) uniform Data {
		mat4 u_projection;
		mat4 u_view;
		mat4 u_proj_to_model;
		vec4 u_center;
		ivec2 u_tile;
		ivec2 u_tile_size;
		int u_size;
	};

	vec2 worldToImpostor(vec3 vec)
	{
		vec.y = min(vec.y, -0.001);
		vec = normalize(vec);
		vec.xz /= dot(vec3(1.0), abs(vec));
		return vec2(vec.x + vec.z, vec.x - vec.z) * 0.5 + 0.5;
	}

	float getShadow(vec2 tile_uv, float depth, vec3 v_shadow) {
		v_shadow = normalize(v_shadow);
		if (depth == 0) return 0;
		ivec2 shadow_tile = ivec2(0.5 + worldToImpostor(v_shadow) * (u_size - 1)); 

		vec3 up = vec3(0, 1, 0);
		mat4 model_sm;
		model_sm[0] = vec4(normalize(cross(up, -v_shadow)), 0);
		model_sm[1] = vec4(normalize(cross(-v_shadow, model_sm[0].xyz)), 0);
		model_sm[2] = vec4(-v_shadow, 0);
		model_sm[3] = vec4(0, 0, 0, 1);
		model_sm = transpose(model_sm);
		mat4 to_sm = u_projection * u_view * model_sm * u_proj_to_model;

		float res = 0;
		vec4 p = to_sm * vec4(tile_uv * 2 - 1, depth, 1);
		p.xy = p.xy * 0.5 + 0.5;
		p.xyz /= p.w;
		const int SPREAD = 0;
		for(int j = -SPREAD; j <= SPREAD; ++j) {
			for(int i = -SPREAD; i <= SPREAD; ++i) {
				vec4 p2 = p;
				p2.xy += vec2(i, j) / u_tile_size / 2;
				if (any(lessThan(p2.xy, vec2(0))) || any(greaterThan(p2.xy, vec2(1)))) {
					res += 1;
				}
				else {
					float shadow_depth = texture(u_depth, (p2.xy + shadow_tile.xy) / float(u_size)).r;
					res += shadow_depth * 0.99 < p.z ? 1 : 0;
				}
			}
		}

		return res / (2 * SPREAD + 1) /  (2 * SPREAD + 1);
	}

	void main() {
		if (any(greaterThan(gl_GlobalInvocationID.xy, u_tile_size))) return;

		vec2 tile_uv = gl_GlobalInvocationID.xy / vec2(u_tile_size);
		vec2 uv = (u_tile + tile_uv) / float(u_size);
		float depth = texture(u_depth, uv).r;

		float zenith = -0.5;
		vec4 res = vec4(
			0.5 * getShadow(tile_uv, depth, vec3(1, zenith, 0)) + 0.25 * getShadow(tile_uv, depth, vec3(1, zenith, -0.2)) + 0.25 * getShadow(tile_uv, depth, vec3(1, zenith, 0.2)),
			0.5 * getShadow(tile_uv, depth, vec3(0, zenith, -1)) + 0.25 * getShadow(tile_uv, depth, vec3(0.2, zenith, -1)) + 0.25 * getShadow(tile_uv, depth, vec3(-0.2, zenith, -1)),
			0.5 * getShadow(tile_uv, depth, vec3(-1, zenith, 0)) + 0.25 * getShadow(tile_uv, depth, vec3(-1, zenith, 0.2)) + 0.25 * getShadow(tile_uv, depth, vec3(-1, zenith, -0.2)),
			0.5 * getShadow(tile_uv, depth, vec3(0, zenith, 1)) + 0.25 * getShadow(tile_uv, depth, vec3(0.2, zenith, 1)) + 0.25 * getShadow(tile_uv, depth, vec3(-0.2, zenith, 1))
		);

		imageStore(u_output, ivec2(gl_GlobalInvocationID.xy + u_tile * u_tile_size), res);
	}
]]